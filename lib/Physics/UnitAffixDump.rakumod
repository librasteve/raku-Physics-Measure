unit module Physics::UnitAffixDump:ver<0.0.4>:auth<Steve Roe (p6steve@furnival.net)>;
use Physics::Unit;

######## Declarations #######
my @affix-prefix;
my @affix-names;
my %affix-tag;         #ie. Define tags for UnitAffix import

######## Subroutines ########
sub InitAffixPrefixes( @_ ) {
    for @_ -> $p, $s {
        @affix-prefix.push: $p => $s
    }
}
sub InitAffixNames( @_ ) {
    for @_ -> $n, $s {
        @affix-names.push: $n => $s
    }
}
sub InitAffixTags( @_ ) {
    for @_ -> $n, $t {
        %affix-tag{$n} = $t;
    }
}

###### Data Definition ######
InitAffixPrefixes (
    '',   '',
    'da', 'deka',
    'h',  'hecto',
    'k',  'kilo',
    'M',  'mega',
    'G',  'giga',
    'T',  'tera',
    'P',  'peta',
    'E',  'exa',
    'Z',  'zetta',
    'Y',  'yotta',
    'd',  'deci',
    'c',  'centi',
    'm',  'milli',
    'μ',  'micro',
    'n',  'nano',
    'p',  'pico',
    'f',  'femto',
    'a',  'atto',
    'z',  'zepto',
    'y',  'yocto',
);

InitAffixNames (
    'm',   'metre',
    'g',   'gram',
    's',   'second',
    'A',   'amp',
    'K',   'kelvin',
    'mol', 'mol',
    'cd',  'candela',
    'Hz',  'hertz',
    'N',   'newton',
    'Pa',  'pascal',
    'J',   'joule',
    'W',   'watt',
    'C',   'coulomb',
    'V',   'volt',
    'F',   'farad',
    'Ω',   'ohm',
    'S',   'siemens',
    'Wb',  'weber',
    'T',   'tesla',
    'H',   'henry',
    'lm',  'lumen',
    'lx',  'lux',
    'Bq',  'becquerel',
    'Gy',  'gray',
    'Sv',  'sievert',
    'kat', 'katal',
    'l',   'litre',     #add due to common use of ml, dl, etc.
## these replaced with non-declining singletons in UnitAffix::LoadAffixOps
#   '°',   'degrees',   #remove due to lack of demand for eg. yotta°'s
#   'rad', 'radian',    #remove use 'radian' due to confusion with rad Dose
#   'sr',  'steradian', #remove due to lack of demand for yottasr's
#   '°C',  'celsius',   #remove due to lack of demand for yotta°C's
);

InitAffixTags (
     'm',   ':DEFAULT',
     'g',   ':DEFAULT',
     's',   ':DEFAULT',
     'A',   ':electrical',
     'K',   ':mechanical',
     'mol', ':mechanical',
     'cd',  ':universal',
     'Hz',  ':mechanical',
     'N',   ':mechanical',
     'Pa',  ':mechanical',
     'J',   ':mechanical',
     'W',   ':mechanical',
     'C',   ':electrical',
     'V',   ':electrical',
     'F',   ':electrical',
     'Ω',   ':electrical',
     'S',   ':electrical',
     'Wb',  ':electrical',
     'T',   ':electrical',
     'H',   ':electrical',
     'lm',  ':universal',
     'lx',  ':universal',
     'Bq',  ':universal',
     'Gy',  ':universal',
     'Sv',  ':universal',
     'kat', ':universal',
     'l',   ':DEFAULT',
);

#### Affix: SI Prefix X SI Units Abbreviated for Postfix Operators ####

#|To facilitate intuitive access to Physics::Unit, the sister Physics::UnitAffix module is
#|provided with a laundry list of predefined units that cover all combinations
#|of affix-prefix X affix-names (as defined above). Using the postfix syntax, literally 
#| $l = 1m; (note no space) will return a Measure::Length object.
#|
#|Since there are 20 prefixes and 30 names, this is adding 600 custom operators to the name
#|space, so they need to be autogenerated. 
#|
#|eg. sub postfix:<m> ( Real:D $x ) is export(:DEFAULT) { do-postfix( $x, 'm' ) }
#|
#|Lastly, paste them in to Physics::UnitAffix.rakumod at ~2500-3100 ish.

sub DumpAffixOps( Junction:D $want-tags = <:DEFAULT>.any ) is export {
    for @affix-names -> $name {
        for @affix-prefix -> $prefix {
            my $o = $prefix.key ~ $name.key;
			my $t = %affix-tag{$name.key};
			if $t ~~ $want-tags || $want-tags.any ~~ <:ALL> {

say q|sub postfix:<\qq[$o]> (Real:D $x) is export(\qq[$t]) { do-postfix($x,'\qq[$o]') }|

			}
        }
    }
}

#|And since you want all these 600 units pre built for performance, use this sub to generate
#|them. This takes ca 30 minutes on my crappy machine. 
#|
#|This sub also weeds out the unprefixed BaseUnits already defined in Unit.rakumod...

my $exclusions = <m km g kg s A K mol cd>.any;

sub DumpAffixUnits( Junction:D $want-tags = <:DEFAULT>.any ) is export {
    for @affix-names -> $name {
        for @affix-prefix -> $prefix {
            my $opcode = $prefix.key ~ $name.key;
            my $opdefn = $prefix.value ~ $name.value;
			next if $opcode ~~ $exclusions;
			next unless %affix-tag{$name.key} ~~ $want-tags || $want-tags.any ~~ <:ALL>;
			InitUnit( ( [$opcode], $opdefn ) );
			GetUnit( $opcode ).raku( :stock ).say;
        }
    }
}

#EOF
